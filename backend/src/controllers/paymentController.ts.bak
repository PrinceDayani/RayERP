import { Request, Response } from 'express';
import Payment from '../models/Payment';
import Invoice from '../models/Invoice';
import { JournalEntry } from '../models/JournalEntry';
import { Account } from '../models/Account';
import mongoose from 'mongoose';

export const createPayment = async (req: Request, res: Response) => {
  const session = await mongoose.startSession();
  session.startTransaction();

  try {
    if (!req.user) {
      return res.status(401).json({ success: false, message: 'Authentication required' });
    }

    const paymentData = {
      ...req.body,
      createdBy: req.user.id
    };

    // Generate payment number if not provided
    if (!paymentData.paymentNumber) {
      const count = await Payment.countDocuments();
      paymentData.paymentNumber = `PAY-${new Date().getFullYear()}-${String(count + 1).padStart(4, '0')}`;
    }

    const payment = new Payment(paymentData);
    await payment.save({ session });

    // Update related invoices if any
    if (payment.invoiceIds && payment.invoiceIds.length > 0) {
      for (const invoiceId of payment.invoiceIds) {
        const invoice = await Invoice.findById(invoiceId).session(session);
        if (invoice) {
          invoice.paidAmount += payment.amount;
          
          if (invoice.paidAmount >= invoice.totalAmount) {
            invoice.status = 'paid';
          }

          await invoice.save({ session });
        }
      }
    }

    // Create journal entry if payment is completed
    if (payment.status === 'completed') {
      await createPaymentJournalEntry(payment, req.user.id, session);
    }

    await session.commitTransaction();

    const populatedPayment = await Payment.findById(payment._id)
      .populate('customerId', 'name email')
      .populate('invoiceIds', 'invoiceNumber totalAmount')
      .populate('createdBy', 'name email');

    res.status(201).json({
      success: true,
      data: populatedPayment,
      message: 'Payment created successfully'
    });
  } catch (error: any) {
    await session.abortTransaction();
    res.status(400).json({ success: false, message: error.message });
  } finally {
    session.endSession();
  }
};

export const getPayments = async (req: Request, res: Response) => {
  try {
    const {
      status,
      paymentMethod,
      customerId,
      startDate,
      endDate,
      page = 1,
      limit = 20
    } = req.query;

    const filter: any = {};
    if (status) filter.status = status;
    if (paymentMethod) filter.paymentMethod = paymentMethod;
    if (customerId) filter.customerId = customerId;
    
    if (startDate || endDate) {
      filter.paymentDate = {};
      if (startDate) filter.paymentDate.$gte = new Date(startDate as string);
      if (endDate) filter.paymentDate.$lte = new Date(endDate as string);
    }

    const skip = (Number(page) - 1) * Number(limit);

    const [payments, total] = await Promise.all([
      Payment.find(filter)
        .populate('customerId', 'name email')
        .populate('invoiceIds', 'invoiceNumber totalAmount')
        .populate('createdBy', 'name email')
        .sort({ paymentDate: -1 })
        .skip(skip)
        .limit(Number(limit)),
      Payment.countDocuments(filter)
    ]);

    res.json({
      success: true,
      data: payments,
      pagination: {
        total,
        page: Number(page),
        limit: Number(limit),
        pages: Math.ceil(total / Number(limit))
      }
    });
  } catch (error: any) {
    res.status(500).json({ success: false, message: error.message });
  }
};

export const getPaymentById = async (req: Request, res: Response) => {
  try {
    const payment = await Payment.findById(req.params.id)
      .populate('customerId', 'name email address')
      .populate('invoiceIds', 'invoiceNumber totalAmount balanceAmount')
      .populate('createdBy', 'name email')
      .populate('journalEntryId');

    if (!payment) {
      return res.status(404).json({ success: false, message: 'Payment not found' });
    }

    res.json({ success: true, data: payment });
  } catch (error: any) {
    res.status(500).json({ success: false, message: error.message });
  }
};

export const updatePayment = async (req: Request, res: Response) => {
  const session = await mongoose.startSession();
  session.startTransaction();

  try {
    if (!req.user) {
      return res.status(401).json({ success: false, message: 'Authentication required' });
    }

    const payment = await Payment.findById(req.params.id).session(session);
    
    if (!payment) {
      return res.status(404).json({ success: false, message: 'Payment not found' });
    }

    // Prevent modification of completed payments
    if (payment.status === 'completed') {
      return res.status(400).json({
        success: false,
        message: 'Cannot modify completed payment'
      });
    }

    const oldStatus = payment.status;
    Object.assign(payment, req.body);

    await payment.save({ session });

    await session.commitTransaction();

    const populatedPayment = await Payment.findById(payment._id)
      .populate('customerId', 'name email')
      .populate('invoiceIds', 'invoiceNumber totalAmount');

    res.json({
      success: true,
      data: populatedPayment,
      message: 'Payment updated successfully'
    });
  } catch (error: any) {
    await session.abortTransaction();
    res.status(400).json({ success: false, message: error.message });
  } finally {
    session.endSession();
  }
};

export const deletePayment = async (req: Request, res: Response) => {
  try {
    const payment = await Payment.findById(req.params.id);
    
    if (!payment) {
      return res.status(404).json({ success: false, message: 'Payment not found' });
    }

    // Prevent deletion of completed payments
    if (payment.status === 'completed') {
      return res.status(400).json({
        success: false,
        message: 'Cannot delete completed payment'
      });
    }

    await Payment.findByIdAndDelete(req.params.id);

    res.json({
      success: true,
      message: 'Payment deleted successfully'
    });
  } catch (error: any) {
    res.status(500).json({ success: false, message: error.message });
  }
};

// Helper function to create payment journal entry
const createPaymentJournalEntry = async (payment: any, userId: any, session: any) => {
  const lines = [];

  // Debit Cash/Bank Account
  const cashAccount = await getCashAccount(payment.paymentMethod);
  lines.push({
    account: cashAccount,
    accountId: cashAccount,
    debit: payment.totalAmount,
    credit: 0,
    description: `Payment received - ${payment.paymentNumber}`
  });

  // Credit Accounts Receivable
  const arAccount = await getAccountByType('ACCOUNTS_RECEIVABLE');
  lines.push({
    account: arAccount,
    accountId: arAccount,
    debit: 0,
    credit: payment.totalAmount,
    description: `Payment from ${payment.customerName}`
  });

  const journalEntry = new JournalEntry({
    entryNumber: `PAY-${payment.paymentNumber}`,
    entryType: 'MANUAL',
    status: 'POSTED',
    date: payment.paymentDate,
    entryDate: payment.paymentDate,
    postingDate: new Date(),
    periodYear: payment.paymentDate.getFullYear(),
    periodMonth: payment.paymentDate.getMonth() + 1,
    description: `Payment ${payment.paymentNumber} from ${payment.customerName}`,
    reference: payment.reference,
    lines,
    totalDebit: payment.totalAmount,
    totalCredit: payment.totalAmount,
    isPosted: true,
    sourceType: 'MANUAL',
    sourceId: payment._id,
    createdBy: userId,
    postedBy: userId
  });

  await journalEntry.save({ session });

  // Update account balances
  for (const line of lines) {
    await Account.findByIdAndUpdate(
      line.account,
      { $inc: { balance: line.debit - line.credit } },
      { session }
    );
  }

  payment.journalEntryId = journalEntry._id;
  await payment.save({ session });
};

// Helper functions
const getCashAccount = async (paymentMethod: string) => {
  const accountNames: any = {
    'CASH': 'Cash',
    'CHEQUE': 'Bank Account',
    'BANK_TRANSFER': 'Bank Account',
    'UPI': 'Bank Account',
    'CARD': 'Bank Account',
    'NEFT': 'Bank Account',
    'RTGS': 'Bank Account',
    'WALLET': 'Digital Wallet'
  };

  const accountName = accountNames[paymentMethod] || 'Cash';
  return await getAccountByType('CASH', accountName);
};

const getAccountByType = async (type: string, name?: string) => {
  const accountMap: any = {
    'ACCOUNTS_RECEIVABLE': { type: 'asset', name: name || 'Accounts Receivable' },
    'CASH': { type: 'asset', name: name || 'Cash' }
  };

  const accountInfo = accountMap[type];
  if (!accountInfo) throw new Error(`Unknown account type: ${type}`);

  let account = await Account.findOne({ 
    type: accountInfo.type, 
    name: { $regex: accountInfo.name, $options: 'i' } 
  });

  if (!account) {
    account = new Account({
      code: `${accountInfo.type.toUpperCase()}-${type}`,
      name: accountInfo.name,
      type: accountInfo.type,
      balance: 0,
      openingBalance: 0,
      currency: 'INR',
      isActive: true,
      isGroup: false,
      allowPosting: true,
      createdBy: new mongoose.Types.ObjectId()
    });
    await account.save();
  }

  return account._id;
};

export default {
  createPayment,
  getPayments,
  getPaymentById,
  updatePayment,
  deletePayment
};